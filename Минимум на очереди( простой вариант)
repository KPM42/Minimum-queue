/*
Ключевая идея заключается в том, чтобы реально хранить в очереди не все элементы,
а только нужные нам для определения минимума.
А именно, пусть очередь представляет собой неубывающую последовательность чисел (т.е. в голове хранится наименьшее значение),
причём, разумеется, не произвольную, а всегда содержащую минимум.
Тогда минимум во всей очереди всегда будет являться первым её элементом.
Перед добавлением нового элемента в очередь достаточно произвести "срезку":
пока в хвосте очереди находится элемент, больший нового элемента, будем удалять этот элемент из очереди;
затем добавим новый элемент в конец очереди.
Тем самым мы, с одной стороны, не нарушим порядка, а с другой стороны, не потеряем текущий элемент,
если он на каком-либо последующем шаге окажется минимумом.
Но при извлечении элемента из головы очереди его там, вообще говоря,
может уже не оказаться - наша модифицированная очередь могла выкинуть этот элемент в процессе перестроения.
Поэтому при удалении элемента нам надо знать значение извлекаемого элемента - если элемент с 
этим значением находится в голове очереди, то извлекаем его;
иначе просто ничего не делаем.
*/

deque<int> q;

int getmin()
{
	return q.front(); // минимум - начало дека
}

void add(int elem)
{
	while (!q.empty() && q.back() > elem) // пока добавляемый элемент меньше элемента на вершине дека - удаляем элемент из вершины дека
		q.pop_back();
	
	q.push_back(elem); // после этого добавляем элемент в дек
}

void remove(int elem)
{
	if (!q.empty() && q.front() == elem) // если удаляемый элемент равен текущему тек. минимуму - удалим из начала
		q.pop_front();
}

/* задача нахождения минимума во всех подотрезках фикс. длины k:
добавим первые k элементов в дек, имеем минимум на отрезке 0..k-1, далее
будем делать переход - удалять a[i-k] элемент и добавлять a[i] элемент, 
тем самым снова получая минимум
*/
